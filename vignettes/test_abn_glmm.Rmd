---
title: "Playground abn with glmm"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Playground abn with glmm}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(bnaiaR)
# renv::install("url::https://git.math.uzh.ch/mdeluc/devel-abn/-/archive/v3.0.0.9000/devel-abn-v3.0.0.9000.tar.gz")
# renv::install("gitlab@git.math.uzh.ch::mdeluc/devel-abn/-/releases/v3.0.0.9000")
# renv::install("gitlab@git.math.uzh.ch::mdeluc/devel-abn/abn")
# renv::install("../../../rrr/devel-abn/abn_3.0.0.9000.tar.gz")
library(abn)
# renv::install("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"))
```

```{r}
SEED <- 123456789
```

# Data preparation

```{r}
data("exp4_dat")
df5 <- exp4_dat$abndata
str(df5)
```


```{r}
df51 <- df5
str(df51)
(banned51 <- exp4_dat$banned)
(retain51 <- exp4_dat$retain)
(dist51 <- exp4_dat$dist)
```

# ABN with glmm

```{r}
mycache <- buildScoreCache(method="mle",
                           data.df=df51,
                           data.dists=dist51[-10], # all except study_source
                           group.var="study_source",
                           dag.banned = banned51[-10, -10], # all except study_source
                           dag.retained = retain51[-10, -10], # all except study_source
                           max.parents=9,
                           control = build.control(catcov.mblogit = "diagonal",
                                                   seed = SEED),
                           verbose = FALSE)
```

```{r}
mp.dag <- mostProbable(mycache)
```

```{r}
myres <- fitAbn(method="mle", 
                object = mp.dag, 
                group.var = "study_source",
                control = fit.control(catcov.mblogit = "diagonal",
                                      seed = SEED))
```

```{r}
plotAbn(myres)
```

```{r}
dfsim <- simulateAbn(object = myres,
                     verbose = TRUE,
                     seed = SEED,
                     run.simulation = TRUE,
                     n.chains = 100,
                     n.iter = 1e5,
                     n.thin = 1e3,
                     n.adapt = 1e2)
# dfsim <- simulateAbn(object = myres, 
#                      verbose = TRUE, 
#                      seed = SEED, 
#                      run.simulation = TRUE)
```
IAsize and age have been centered around zero and therefore can have negative values.


No group.var from here on. Because we cannot simulate the grouping variable because we do not have meaningful predictors for it.

```{r}
dist51_sim <- dist51[-10]
# dist51_sim["IAlocation_group"] <- "binomial"
# tmp <- as.integer(dfsim$positive_famillial_history)
# tmp[1] <- 2
# dfsim$positive_famillial_history <- factor(tmp)
mycache_sim <- buildScoreCache(method="mle",
                           data.df=dfsim[, names(dist51[-10])], # reordered to match data.dists
                           data.dists=dist51_sim, # all except study_source
                           # group.var="study_source",
                           dag.banned = banned51[-10, -10], # all except study_source
                           dag.retained = retain51[-10, -10], # all except study_source
                           max.parents=9,
                           verbose = FALSE)
```

```{r}
mp.dag_sim <- mostProbable(mycache_sim)
```

```{r}
myres_sim <- fitAbn(method="mle", object = mp.dag_sim)
```

```{r}
plotAbn(myres_sim)
```

## parametric bootstrapping

Estimate initial best Graph $\mathcal{G_0}$ from the original, real-world data $\mathcal{D_0}$.
Let $N$ the number of bootstrap samples.

We simulate N data set $\mathcal{D_1}, \dots, \mathcal{D_n}$ from model $\mathcal{G_0}$
and estimate N new models $\mathcal{G_1}, \dots, \mathcal{G_n}$ from the respective simulated data.

For the final model $\mathcal{G_{sum}}$, we summarise over all $\mathcal{G_1}, \dots, \mathcal{G_n}$.

The consensus model $\mathcal{G_{consensus}}$ is the trimmed $\mathcal{G_{sum}}$ based on accepting only significant edges.

```{r}
#' Parameteric Bootstrapping
#'
#' @param object of class abnFit 
#' @param n.sim number of bootstrap iterations.
#' @param dag.banned a matrix or a formula statement defining which arcs are not permitted - banned. Note that colnames and rownames must be set, otherwise same row/column names as data.df will be assumed. If set as NULL an empty matrix is assumed.
#' @param dag.retained a matrix or a formula statement defining which arcs are must be retained in any model search. Note that colnames and rownames must be set, otherwise same row/column names as data.df will be assumed. If set as NULL an empty matrix is assumed.
#' @param btseeds integer vector with individual seeds for each simulation. Requires one, unique seed for each iteration.
#' @param verbose print more output.
#'
#' @return list of abn fit objects
paramBootAbn <- function(object, 
                         n.sim, 
                         dag.banned,
                         dag.retained,
                         max.parents, 
                         btseeds,
                         verbose = FALSE){
  ## Prepare inputs
  # check if n.sim and btseeds are valid
  if(!(is.null(n.sim) || is.integer(n.sim))){
    if (!(is.null(btseeds) || all(is.integer(btseeds))) && (length(btseeds) == n.sim)){
      if (verbose) message(paste("btseeds (", btseeds, ") and n.sim (", n.sim, ") are ok."))
    } else {
      stop("btseeds must be a vector of integers with length equal to the value of n.sim.")
    }
  } else {
    stop("n.sim must be an integer >= 1.")
  }
  if(!inherits(object, "abnFit")){
    stop("'object' must be of class 'abnFit'.")
  } else {
    dag <- object$abnDag$dag
    data.df <- object$abnDag$data.df
    data.dists <- object$abnDag$data.dists
    group.var <- object$abnDag$group.var
    group.ids <- object$abnDag$group.ids
  }
  
  ## Prepare output collection
  out <- list()
  
  ## Actual bootstrapping
  i <- 1
  while (i <= n.sim) {
    dfsim <- simulateAbn(object = object, 
                         n.iter = as.numeric(nrow(data.df)), # Sample set has equal size as original data
                         verbose = verbose,
                         seed = btseeds[i],
                         run.simulation = TRUE)

    buildCache_failed <- FALSE
    tryCatch({
      mycache_sim <- buildScoreCache(method="mle",
                                     data.df=dfsim[, names(data.dists)], # reordered to match data.dists
                                     data.dists=data.dists, # all except study_source
                                     # group.var="study_source",
                                     dag.banned = dag.banned, 
                                     dag.retained = dag.retained,
                                     max.parents=max.parents,
                                     verbose = verbose)
    }, error = function(e) {buildCache_failed <- TRUE})
    
    if (!buildCache_failed){
      mp.dag_sim <- mostProbable(mycache_sim)
      myres_sim <- fitAbn(method="mle", object = mp.dag_sim)
      
      # append to outputs
      out[[i]] <- list("dfsim" = dfsim,
                       "cache_sim" = mycache_sim,
                       "mpdag_sim" = mp.dag_sim,
                       "fit_sim" = myres_sim)
      # increase iterator
      i <- i+1
    } else {
      # do not update iterator but repeat this step
      i <- i
      if(verbose){message(paste("Simulation no. ", i, "failed and I am repeating it."))}
    }
  }
  return(out)
}
# dags <- paramBootAbn(object = myres, n.sim = 2, btseeds = c(SEED))
# dags <- paramBootAbn(object = myres, n.sim = 1, btseeds = c(SEED, SEED))
# dags <- paramBootAbn(object = myres, n.sim = 1.2, btseeds = c(SEED))

dags <- paramBootAbn(object = myres, 
                     n.sim = 100, 
                     dag.banned = banned51[-10, -10], # all except study_source
                     dag.retained = retain51[-10, -10], # all except study_source
                     max.parents = 4,
                     btseeds = c(1:100)*SEED)
```

```{r}
#' Consensus Model
#' 
#' Return the consensus model from a set of possible models.
#'
#' @param object list of abnFit objects.
#' @param consensusMethod pruning strategy. "signEdge" calculates the consensus model based on accepting only significant edges.
#'
#' @return Consensus model as fitAbn object.
consensusDAG <- function(object, consensusMethod = "signEdges"){
  # create list of adjacency matrices (DAGs)
  dags_list <- list()
  for (i in 1:length(object)){
    dags_list[[i]] <- object[[i]]$mpdag_sim$dag
  }
  
  # adj. matrix with edge frequency
  cumdag <- Reduce("+", dags_list)
  
  # relative edge frequency aka. arc-strength
  reldag <- cumdag / length(dags_list)
  
  if (consensusMethod == "signEdges"){
    # calculate arc-strength threshold
    arc.stren.thr <- bnaiaR::arc.stren.threshold(reldag)
    
    consDAG <- reldag
    consDAG[consDAG<=arc.stren.thr] <- 0
    consDAG[consDAG>arc.stren.thr] <- 1
    
    return(list("arcStrengthThreshold" = arc.stren.thr, 
                "consDAG" = consDAG))
  } else {
    stop(paste("Consensus method", consensusMethod, "is not implemented."))
  }
}
consDAGlist <- consensusDAG(object = dags,
                             consensusMethod = "signEdges")
plotAbn(consDAGlist[["consDAG"]], data.dists = dist51)
```


```{r}
consfit <- fitAbn(dag = consDAGlist[["consDAG"]],
                  data.dists = dist51[-10], 
                  data.df = df51, 
                  method = "mle",
                  group.var = "study_source",
                  control = fit.control(catcov.mblogit = "diagonal",
                                        seed = SEED))
plot(consfit)
print(consfit)
```


