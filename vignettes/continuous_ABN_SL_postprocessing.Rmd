---
title: "Postprocessing of Output from Continuous Additive Bayesian Network Structure Learning"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Postprocessing of Output from Continuous Additive Bayesian Network Structure Learning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r setup}
rm(list = ls())

library(dplyr)
library(tidyr)
library(foreach)
library(coda)
library(abn)
library(mcmcabn)
library(bnaiaR)
library(ggplot2)
```

```{r settings}
SAVEPLOTS <- FALSE
PLOTFORMAT <- "pdf" # "svg", "png"
PLOTWIDTH = 16
PLOTHEIGHT = 9

DEBUG <- TRUE
EXPNO <- "ABNmultinomial"
FILENAME <- paste0("/exp", EXPNO)
# FILENAMEbase <- paste0(Sys.getenv("PLOTPATH"), "/fourierplots")
FILENAMEbase <- paste0(Sys.getenv("PLOTPATH"))
```

# Exp. 4.1: maBN with study_source

```{r load data}
THRESHOLD <- 0.5
METHOD <- "mle"

filenamesuffix <- "4.1"
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_intermediate.RData"))
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_final.RData"))
str(finalresults, max.level = 1)
```


List of all mcmcabn outputs. 
```{r}
length(finalresults$mcmc.out.list)
```

Show first mcmcabn output.
```{r}
str(finalresults$mcmc.out.list[1])
```

DAG from first mcmcabn output. [rows, columns, dags]. dags = number of returned DAGS specified in mcmcscheme.

```{r}
str(finalresults$mcmc.out.list[[1]]$dags)
```


## Max. parents plot

```{r}
maxparentsplot(net.scores, SAVEPLOTS, filenamesuffix, plotwidth = PLOTWIDTH, plotheight = PLOTHEIGHT, filetype = PLOTFORMAT)
```


### Plot DAGs with different max parents

```{r}
dagswithdiffparentsplt(net.scores.dags, df, SAVEPLOTS, filenamesuffix)
```

## Preprocess
### Thin and Burn-in

thinning: mcmc.scheme = c(number of returned DAGS, thinned steps, length of burn-in phase)

```{r}
THINNING <- 1 # keep every second draw
BURNIN.LEN <- 1 # remove the first n draws
# THINNING <- 7
# BURNIN.LEN <- 25000 # remove the first n draws

mcmc.out.list.burn <- postBURNin(mcmc.out.list = finalresults$mcmc.out.list, burnin.length = BURNIN.LEN)
mcmc.out.list.thin <- postTHINN(mcmc.out.list = finalresults$mcmc.out.list, thinningsteps = THINNING)
mcmc.out.list.burn.thin <- postTHINN(mcmc.out.list = mcmc.out.list.burn, thinningsteps = THINNING)
str(mcmc.out.list.burn[1])
str(mcmc.out.list.thin[1])
str(mcmc.out.list.burn.thin[1])
```

### Reformat

```{r}
# thinned only
mc.out.thin.1 <- mcmc.out.list.thin[[1]]
mc.out.thin.2 <- mcmc.out.list.thin[[2]]
mc.out.thin.3 <- mcmc.out.list.thin[[3]]
mc.out.thin.4 <- mcmc.out.list.thin[[4]]

mc.out.thin.score.1 <- mcmc(mc.out.thin.1$scores)
mc.out.thin.score.2 <- mcmc(mc.out.thin.2$scores)
mc.out.thin.score.3 <- mcmc(mc.out.thin.3$scores)
mc.out.thin.score.4 <- mcmc(mc.out.thin.4$scores)

list.mc.out.thin.score <- mcmc.list(mc.out.thin.score.1, mc.out.thin.score.2, mc.out.thin.score.3, mc.out.thin.score.4)

# burned and thinned
mc.out.burn.thin.1 <- mcmc.out.list.burn.thin[[1]]
mc.out.burn.thin.2 <- mcmc.out.list.burn.thin[[2]]
mc.out.burn.thin.3 <- mcmc.out.list.burn.thin[[3]]
mc.out.burn.thin.4 <- mcmc.out.list.burn.thin[[4]]

mc.out.burn.thin.score.1 <- mcmc(mc.out.burn.thin.1$scores)
mc.out.burn.thin.score.2 <- mcmc(mc.out.burn.thin.2$scores)
mc.out.burn.thin.score.3 <- mcmc(mc.out.burn.thin.3$scores)
mc.out.burn.thin.score.4 <- mcmc(mc.out.burn.thin.4$scores)

# list.mc <- mcmc.list(mc.score.1, mc.score.2, mc.score.3, mc.score.4)
list.mc.out.burn.thin.score <- mcmc.list(mc.out.burn.thin.score.1, mc.out.burn.thin.score.2, mc.out.burn.thin.score.3, mc.out.burn.thin.score.4)

mc.out.burn.thin.dag.1 <- mc.out.burn.thin.1$dags
mc.out.burn.thin.dag.2 <- mc.out.burn.thin.2$dags
mc.out.burn.thin.dag.3 <- mc.out.burn.thin.3$dags
mc.out.burn.thin.dag.4 <- mc.out.burn.thin.4$dags

list.mc.out.burn.thin.dag <- abind::abind(mc.out.burn.thin.dag.1, mc.out.burn.thin.dag.2, mc.out.burn.thin.dag.3, mc.out.burn.thin.dag.4)
```

## Best fitting DAG

number of max parents per node.

```{r}
finalresults$max.par
```

total arcs.

```{r}
sum(finalresults$dag.maxpar$dag)
summary(finalresults$fabn.maxpar)
```

## MCMC Quality check

### Gelman
```{r}
gelman.diag(x = list.mc.out.thin.score,autoburnin = F) # if higher than 1.1 or 1.2, run chain longer to improve convergence
gelman.plot(list.mc.out.thin.score, autoburnin = F)

if (SAVEPLOTS){
  PLOTNAME <- paste0("_gelmanplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  }
  
} else {
  gelman.plot(list.mc.out.thin.score, autoburnin = T)
}
```

### Raftery

calculate no. of iterations and no. of burn-ins to satisfy specified conditions.

```{r}
raftery.diag(unlist(list.mc.out.thin.score))
```

### Heidelberg and Welch Diagnostics

test H0: The Markov Chain is from a stationary distribution. If not passed, chain must run longer.

```{r}
for (chain in 1:length(list.mc.out.thin.score)){
  print("------------------------")
  print(paste("Chain no: ", chain))
  print(heidel.diag(list.mc.out.thin.score[[chain]]))
}

```

### Trace Plot

```{r}
mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
# SAVEPLOTS <- T
if (SAVEPLOTS){
  PLOTNAME <- paste0("_traceplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } 
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
  }
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_maxscore"
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
}
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_classic"
  plot(list.mc.out.burn.thin.score)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  plot(list.mc.out.burn.thin.score)
}
```

```{r do we need this?}
# ## traceplot
# fabn <-fitAbn(dag = dag.maxpar$dag,
#               data.df = abndata,
#               data.dists = dist, 
#               method = METHOD) 
# 
# max.score <- -fabn$bic
# 
# dta <- data.frame(mc.out.thin.1[2:4],
#                   mc.out.thin.2[2:4],
#                   mc.out.thin.3[2:4],
#                   mc.out.thin.4[2:4]) # Thinned but not burned
# 
# dta <- dta[,c(1,4,7,10)]
# # dta <- dta[thin, ]
# names(dta) <- c("Run1","Run2","Run3","Run4")
# dta$X <- (1:length(dta$Run1))
# dta <- reshape2::melt(dta, "X", value.name = "scores")
# 
# dta$cummax[1] <- dta$scores[1]
# for (i in 2:length(dta$scores)) {
#   if (dta$scores[i] > dta$cummax[i - 1]) {
#     dta$cummax[i] <- dta$scores[i]
#     } else {
#       dta$cummax[i] <- dta$cummax[i - 1]
#     }
# }
# 
# # Create a text
# 
# original_plot <- ggplot(data = dta, aes_string(x = "X", y="scores", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1) +
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score,alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # print(original_plot)
# 
# # Plot
# y_density <- cowplot::axis_canvas(original_plot, axis = "y", coord_flip = TRUE) +
#   geom_density(data = dta, aes_string(x = "scores",fill = "factor(variable)"), alpha = 0.5) +
#   coord_flip()
# 
# cummax_plt <- ggplot(data = dta, aes_string(x = "X", y="cummax", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1, inherit.aes = T) +
#   geom_point(aes_string(color = "variable"), inherit.aes = T)+
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score, alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # cummax_plt
# 
# # create the combined plot
# combined_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right"))
# combined_cummax_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = cummax_plt, position = "right"))
# # ggsave(paste0(FILENAMEbase, FILENAME, "traceplot_combined.png"),
# #        plot = cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right")),
# #        width = 9,height = 7)
# # dev.off()
# # print(combined_plot)
# 
# if (SAVEPLOTS){
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_combined")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_cummax")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
#   } else {
#   original_plot
#   combined_plot 
#   cummax_plt
# }
```

## Consensus DAG

best dag trimmed for controlling overfitting

```{r}
# Best DAG not trimmed 
dag.mcmc.boot <- apply(list.mc.out.burn.thin.dag, 1:2, mean)
colnames(dag.mcmc.boot) <- rownames(dag.mcmc.boot) <- names(finalresults$dist)

# Best DAG Trimmed on THRESHOLD
dag.mcmc.boot.th <- dag.mcmc.boot
dag.mcmc.boot.th[dag.mcmc.boot.th>THRESHOLD]<-1
dag.mcmc.boot.th[dag.mcmc.boot.th<=THRESHOLD]<-0

# Plot Best DAG trimmed
cons.dag.plt <- plotAbn(dag = dag.mcmc.boot.th,data.dists = finalresults$dist, 
                        node.shape = c("box", "box", "box", "box"),
                        plot = F)


if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag"
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
  abn::toGraphviz(dag.mcmc.boot.th,
                  data.dists = finalresults$dist,
                  data.df = finalresults$df,
                  outfile = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".dot"),
                  directed=TRUE)
  saveRDS(dag.mcmc.boot.th, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".rds"))

  } else {
  cons.dag.plt
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  }
```


## Arc strength significance threshold

```{r}
dag.mcmc.boot.stren <- as.vector(round(dag.mcmc.boot, 3))
arc.stren.sign.threshold <-arc.stren.threshold(dag.mcmc.boot.stren)


# relative arc strength
plot(ecdf(dag.mcmc.boot.stren))
abline(v = arc.stren.sign.threshold, lty=2)
abline(v=0.5)

# # absolute arc strength
# plot(ecdf(apply(list.mc.out.burn.thin.dag, 1:2, sum)))

if (SAVEPLOTS){
  PLOTNAME <- "_cdf_arcstrength"
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
}
```

Difference in DAG between two arc strength thresholds:
```{r}
# relative frequency of an arc appearing in the MCMC sample
x <- dag.mcmc.boot

x[which(x<THRESHOLD & x>arc.stren.sign.threshold)]
x[which(x<THRESHOLD & x>arc.stren.sign.threshold-0.01)] <- 100 # Assign impossible value to highlight arc
x
```


```{r}
# Fit best DAG trimmed 
fabn.boot.th.mle <-fitAbn(dag = dag.mcmc.boot.th,
              data.df = finalresults$df,
              data.dists = finalresults$dist, 
              method = METHOD,
              compute.fixed = T,
              create.graph = T)

fabn.boot.th.mle$bic
infoDag(dag.mcmc.boot.th)

# plot with arc strength
plotdag <- dag.mcmc.boot
plotdag[plotdag>THRESHOLD]<-1
plotdag[plotdag<=THRESHOLD]<-0

fitvals <- fabn.boot.th.mle$coef

for (i in 1:length(fitvals)){
  names(fitvals[[i]]) <- colnames(fitvals[[i]])
}

edgestren <- round(dag.mcmc.boot, 2)
edgestren[edgestren<=THRESHOLD]<-0

cons.dag.plt.edgestrength <- plotAbn(dag = plotdag,
        data.dists = dist,
        # fitted.values = fitvals,
        digits = 2,
        # edge.strength = edgestren,
        # edge.arrowsize = "undirected",
        node.shape = c("box", "box", "box", "box"),
        plot = F)

attrs <- list(node=list(shape="rectangle", fixedsize=FALSE))
if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag_edgestrength"
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
}
```

TODO: fix edge direction. They're all in the wrong direction...


## Inference

```{r}
# Fit best trimmed DAG with MLE framework to compute marginals
fabn.boot.th.mle <-fitAbn(dag = dag.mcmc.boot.th,
              data.df = finalresults$df,
              data.dists = finalresults$dist, 
              method = "mle",
              compute.fixed = T,
              create.graph = T)

# out.bayes <- unlist(fabn.boot.th.bayes$modes)
out.mle <- unlist(fabn.boot.th.mle$coef, use.names = T)
```
TODO: keep the names. Unlist manually...
```{r}
##numeric
df.mle <- as.data.frame(out.mle) %>%
  tibble::rownames_to_column()%>%
  filter(!stringr::str_detect(rowname, "precision") &
           !stringr::str_detect(rowname, "Intercept"))

# df.bayes
df.mle
```

### Maximum Likelihood Estimation 

#### Regression coefficient estimates and 95% Confidence Intervals (CI)

with their interpretation and data support (computed with structural MCMC).

Second table `spportdag` is the percentage of the individual arcs supported by the 
MCMC sample. 


TODO: CONTINUE HERE! Think about the results table with random
```{r eval=FALSE, include=FALSE}
basicresulttable <- function(FITABN=fabn.boot.th.mle, SUPPORTDAG=dag.mcmc.boot){
  PREPROCESSEDDATA_df <- data("adbisgc", package = "bnaiaR")
  fabn.boot.th.mle <- FITABN
  dag.mcmc.boot <- SUPPORTDAG
  
  # Look-up table for interpretation of results depending on variable distribution
  interpretLUT <- lapply(fabn.boot.th.mle$abnDag$data.dists, function(x){
    if(x=="binomial"){
      "log odds ratio"
    } else if(x=="gaussian"){
      "correlation"
    } else if(x=="poisson"){
      "log rate ratio"
    } else if(x=="multinomial"){
      "log odds ratio"
    }
  })
browser()  
  # Extract each edge (cornames) and it's interpretation
  cornames <- c()
  interpret <- c()
  for (i in 1:length(fabn.boot.th.mle$coef)){
    for (j in colnames(fabn.boot.th.mle$coef[[i]])){
      interpret <- c(interpret, interpretLUT[which(names(unlist(interpretLUT)) == names(fabn.boot.th.mle$coef[i]))][[1]])
      if(stringr::str_detect(j, "intercept")){
        cornames <- c(cornames, j)
      } else {
          cornames <- c(cornames, paste0(names(fabn.boot.th.mle$coef[i]), "|", j))
        }
    }
  }
  
  # each edge's support aka. arc-strength
  possibleLevels <- c("\\.Former", "\\.No", "\\.Current", "\\.No", "\\.Yes", "\\.Low", "\\.Medium", "\\.High", "High", "Low", "Medium")
  support <- c()
  from_names <- c()
  from_levels <- c()
  to_names <- c()
  to_levels <- c()
  supportdag <- dag.mcmc.boot
  supportdag[supportdag<=THRESHOLD] <- 0
  for (i in 1:length(cornames)){
    # iterate through all edges in cornames (i.e. "Multiple.IAs|Hypertension")
    
    # split up cornames in from and to names
    edgename <- stringr::str_split(cornames[[i]], pattern = "\\|", simplify = T)
    fromname <- stringr::str_split(edgename[2], "\\.", simplify = T)[1]
    toname <- stringr::str_split(edgename[1], "\\.", simplify = T)[1]
    
    # Look up levels of from and to nodes
    tolevels <- stringr::str_split(as.character(na.omit(stringr::str_match(edgename[2], possibleLevels))), "\\.", simplify = T)
    if (length(tolevels) == 1){
      tolevels <- stringr::str_split(as.character(na.omit(stringr::str_match(edgename[2], possibleLevels))), "\\.", simplify = T)[1]
    } else if (length(tolevels) >= 2){
      tolevels <- stringr::str_split(as.character(na.omit(stringr::str_match(edgename[2], possibleLevels))), "\\.", simplify = T)[1,2]
    } else if (length(tolevels) == 0){
      tolevels <- NA
    }
    
    if(fromname == "location"){
      fromlevels <- stringr::str_split(as.character(na.omit(stringr::str_match(edgename[2], possibleLevels))), "\\.", simplify = T)
    } else {
      fromlevels <- stringr::str_split(as.character(na.omit(stringr::str_match(edgename[1], possibleLevels))), "\\.", simplify = T)
        if (length(fromlevels) == 1){
          fromlevels <- stringr::str_split(as.character(na.omit(stringr::str_match(edgename[1], possibleLevels))), "\\.", simplify = T)[1]
        } else if (length(fromlevels) >= 2){
          fromlevels <- stringr::str_split(as.character(na.omit(stringr::str_match(edgename[1], possibleLevels))), "\\.", simplify = T)[1,2]
        } else if (length(fromlevels) == 0){
          fromlevels <- NA
        }
      }
    
    # fix from and to names here to match in supportdag
    if (fromname == "location"){
      fromname <- "location.grouped"
    } else if(fromname == "Positive"){
      fromname <- "Positive.famillial.history"
    } else if(fromname == "Multiple"){
      fromname <- "Multiple.IAs"
    }
    
    if (toname == "location"){
      toname <- "location.grouped"
    } else if(toname == "Positive"){
      toname <- "Positive.famillial.history"
    } else if(toname == "Multiple"){
      toname <- "Multiple.IAs"
    }
    
    # Fill missing from and to levels
    if (is.na(fromlevels) & fromname != "intercept"){
      fromlevels <- stringr::str_flatten(levels(PREPROCESSEDDATA_df[,fromname]), collapse=", ")
    }
    if (is.na(tolevels) & fromname != "intercept"){
      tolevels <- stringr::str_flatten(levels(PREPROCESSEDDATA_df[,toname]), collapse=", ")
    }
    
    # Retrieve arc strength from supportdag
    fromidx <- which(colnames(supportdag) == fromname)
    toidx <- which(colnames(supportdag) == toname)
    if(identical(fromidx, integer(0)) | identical(toidx, integer(0))){
      support <- c(support, NA)
    } else {
      support <- c(support, round(supportdag[toidx, fromidx], 2))
    }
    
    # collect results
    from_names <- c(from_names, fromname)
    from_levels <- c(from_levels, fromlevels)
    to_names <- c(to_names, toname)
    to_levels <- c(to_levels, tolevels)
  }
  
  # put all together
  result.table <- data.frame(cornames = cornames,
                             from = from_names,
                             fromLevels = from_levels,
                             to = to_names,
                             toLevels = to_levels,
                             coefficient = unlist(fabn.boot.th.mle$coef, use.names = F),
                             SE = unlist(fabn.boot.th.mle$Stderror, use.names = F),
                             interpretation= interpret,
                             support = support)
  return(result.table)
} #EOF basicresulttable

result.table.basic <- basicresulttable(FITABN=fabn.boot.th.mle, SUPPORTDAG=dag.mcmc.boot)
result.table.basic
```


```{r eval=FALSE, include=FALSE}
result.table <- result.table.basic %>%
  # Fix toLevels of Ruptured_IA
  mutate(toLevels = case_when(to == "Ruptured_IA" ~ "No, Yes",
                              TRUE ~ toLevels)) %>%
  # Handle intercepts: fromLevels = intercept and from = to-label (this happens due to some bad algorithm design above)
  mutate(from = case_when(stringr::str_detect(cornames, "intercept") & is.na(fromLevels) & is.na(toLevels) ~ to,
                          stringr::str_detect(cornames, "intercept") & is.na(fromLevels) & !is.na(toLevels) ~ paste(to, toLevels, sep = "="),
                          (from %in% c("location.grouped", "Smoking_Current_Former_No")) & (fromLevels %in% c("Low", "Medium", "High", "Current", "Former", "No")) ~ paste(from, fromLevels, sep = "="),
                          TRUE ~ from),
         fromLevels = case_when(stringr::str_detect(cornames, "intercept") & is.na(fromLevels) ~ "intercept",
                                fromLevels %in% c("Low", "Medium", "High", "Current", "Former", "No") ~ "No, Yes",
                          TRUE ~ fromLevels),
         to = case_when(stringr::str_detect(cornames, "intercept") ~ NA_character_,
                        (to %in% c("location.grouped", "Smoking_Current_Former_No")) & (toLevels %in% c("Low", "Medium", "High", "Current", "Former", "No")) ~ paste(to, toLevels, sep = "="),
                        TRUE ~ to),
         toLevels = case_when((fromLevels == "intercept") ~ NA_character_,
                              toLevels %in% c("Low", "Medium", "High", "Current", "Former", "No") ~ "No, Yes",
                              TRUE ~ toLevels)) %>%
  
  # Clean up node labels
  mutate(fromDirty = from,
         toDirty = to,
         from = case_when(from == "Gender" ~ "Sex",
                          from == "AgeDiag" ~ "Age at Diagnosis",
                          from == "Positive.famillial.history" ~ "Pos. Fam. History",
                          from == "Smoking_Current_Former_No" ~ "Smoking Status",
                          from == "Smoking_Current_Former_No=Current" ~ "Smoking Status=Current",
                          from == "Smoking_Current_Former_No=Former" ~ "Smoking Status=Former",
                          from == "Smoking_Current_Former_No=No" ~ "Smoking Status=No",
                          from == "location.grouped" ~ "IA Location",
                          from == "location.grouped=Low" ~ "IA Location=Low risk",
                          from == "location.grouped=Medium" ~ "IA Location=Medium risk",
                          from == "location.grouped=High" ~ "IA Location=High risk",
                          from == "Multiple.IAs" ~ "Multiple IAs",
                          from == "IAsize_log" ~ "IA Size",
                          from == "Ruptured_IA" ~ "Ruptured IA",
                          TRUE ~ from),
         to = case_when(to == "Gender" ~ "Sex",
                        to == "AgeDiag" ~ "Age at Diagnosis",
                        to == "Positive.famillial.history" ~ "Pos. Fam. History",
                        to == "Smoking_Current_Former_No" ~ "Smoking Status",
                        to == "Smoking_Current_Former_No=Current" ~ "Smoking Status=Current",
                        to == "Smoking_Current_Former_No=Former" ~ "Smoking Status=Former",
                        to == "Smoking_Current_Former_No=No" ~ "Smoking Status=No",
                        to == "location.grouped" ~ "IA Location",
                        to == "location.grouped=Low" ~ "IA Location=Low risk",
                        to == "location.grouped=Medium" ~ "IA Location=Medium risk",
                        to == "location.grouped=High" ~ "IA Location=High risk",
                        to == "Multiple.IAs" ~ "Multiple IAs",
                        to == "IAsize_log" ~ "IA Size",
                        to == "Ruptured_IA" ~ "Ruptured IA",
                          TRUE ~ to)) %>%
  
  # split levels in two columns
  separate(col = fromLevels, into = c("fromLevels0", "fromLevels1")) %>%
  separate(col = toLevels, into = c("toLevels0", "toLevels1")) %>%

  # add odds ratio
  mutate(exp.coefficient = exp(coefficient),
         exp.CI = paste(round(exp(coefficient-SE), 2), "-", round(exp(coefficient+SE), 2)),
         interpretation.exp.coef = case_when(interpretation == "log odds ratio" ~ "odds ratio",
                                             interpretation == "correlation" ~ "exp. corr. coef.",
                                             TRUE ~ NA_character_)) %>%
  # add probabilities
  mutate(prob = exp(coefficient)/(1+exp(coefficient)) # odds/(1+odds)
  )

# Probability interpretation
for (i in 1:nrow(result.table)){
  if (stringr::str_detect(result.table$cornames[i], "intercept") & !(result.table$from[i] %in% c("Age at Diagnosis", "IA Size", "Smoking Status=Former", "Smoking Status=No", "IA Location", "IA Location=Low risk", "IA Location=Medium risk", "IA Location=High risk"))){
    # Intercept
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "=", levels(abndata[ , which(colnames(abndata) == stringr::str_split(result.table$fromDirty[i], "=", simplify = T)[1])])[2], ")")
  } else if (stringr::str_detect(result.table$cornames[i], "intercept") & result.table$from[i] %in% c("Age at Diagnosis", "IA Size")){
    # Intercept continuous
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], ")")
  } else if (stringr::str_detect(result.table$cornames[i], "intercept") & result.table$from[i] %in% c("Smoking Status=Former", "Smoking Status=No", "IA Location", "IA Location=Low risk", "IA Location=Medium risk", "IA Location=High risk")){
    # Intercept multinomial
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], ")")
  } else if(result.table$fromLevels0[i] == "") { 
    # continuous: From
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "= cont. |", result.table$to[i], "=", result.table$toLevels1[i],")")
  } else if(result.table$toLevels0[i] == "") { 
    # continuous: to
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "=", result.table$fromLevels1[i], "|", result.table$to[i], "= cont.)")
  } else if(result.table$fromLevels0[i] == "") { 
    # continuous: From and to
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "= cont. |", result.table$to[i], "= cont.)")
  } else if((is.na(result.table$fromLevels1[i])) & (!is.na(result.table$toLevels1[i]))) { 
    # Multinomial or continuous: From
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "=", result.table$fromLevels0[i], "|", result.table$to[i], "=", result.table$toLevels1[i],")")
  } else if((!is.na(result.table$fromLevels1[i])) & (is.na(result.table$toLevels1[i]))) { 
    # Multinomial or continuous: to
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "=", result.table$fromLevels1[i], "|", result.table$to[i], "=", result.table$toLevels0[i],")")
  } else if (is.na(result.table$fromLevels1[i]) & is.na(result.table$toLevels1[i])) { 
    # Multinomial or continuous: From and to
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "=", result.table$fromLevels0[i], "|",result.table$to[i], "=", result.table$toLevels0[i],")")
  } else if (!is.na(result.table$fromLevels1[i]) & !is.na(result.table$toLevels1[i])) { 
    # Dichotome/Binomial
    result.table$interpretation.prob[i] <- paste0("P(", result.table$from[i], "=", result.table$fromLevels1[i], "|", result.table$to[i], "=", result.table$toLevels1[i],")")
  } else {
    result.table$interpretation.prob[i] <- paste0("WARNING UNCATCHED CASE: P(", result.table$from[i], "=", result.table$fromLevels1[i], "|", result.table$to[i], "=", result.table$toLevels1[i],")")
  }
}
result.table
```
1/(1+exp(fabn.maxpar$coef$Hypertension[1])) * (1-1/(1+exp(fabn.maxpar$coef$Hypertension[2]))) * 1/(1+exp(fabn.maxpar$coef$Hypertension[3]))

```{r eval=FALSE, include=FALSE}
result.table.mle <- result.table %>%
  # round to 2 digits
  mutate(across(where(is.numeric), function(x){round(x, 2)})) %>%
  # selct specific columns and reorder
  select(c(from, fromLevels0, fromLevels1, to, toLevels0, toLevels1, support, exp.coefficient, exp.CI, interpretation.exp.coef, coefficient, SE, interpretation, prob, interpretation.prob, cornames))

if (SAVEPLOTS){
  write.csv(result.table.mle, file = paste0(getwd(), PLOTPATH, FILENAME, "results_table_mle.csv"), row.names = F)
  # write.csv(supportdag, file = paste0(getwd(), PLOTPATH, FILENAME, "individual_arc_support.csv"))
  } else {
    print(result.table.mle)
  }
```

# Exp. 4.2: maBN without study_source

```{r load data}
THRESHOLD <- 0.5
METHOD <- "mle"

filenamesuffix <- "4.2"
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_intermediate.RData"))
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_final.RData"))
str(finalresults, max.level = 1)
```


List of all mcmcabn outputs. 
```{r}
length(finalresults$mcmc.out.list)
```

Show first mcmcabn output.
```{r}
str(finalresults$mcmc.out.list[1])
```

DAG from first mcmcabn output. [rows, columns, dags]. dags = number of returned DAGS specified in mcmcscheme.

```{r}
str(finalresults$mcmc.out.list[[1]]$dags)
```


## Max. parents plot

```{r}
maxparentsplot(net.scores, SAVEPLOTS, filenamesuffix, plotwidth = PLOTWIDTH, plotheight = PLOTHEIGHT, filetype = PLOTFORMAT)
```


### Plot DAGs with different max parents

```{r}
dagswithdiffparentsplt(net.scores.dags, df, SAVEPLOTS, filenamesuffix)
```

## Preprocess
### Thin and Burn-in

thinning: mcmc.scheme = c(number of returned DAGS, thinned steps, length of burn-in phase)

```{r}
# THINNING <- 2 # keep every second draw
# BURNIN.LEN <- 2500 # remove the first n draws
THINNING <- 7
BURNIN.LEN <- 25000 # remove the first n draws

mcmc.out.list.burn <- postBURNin(mcmc.out.list = finalresults$mcmc.out.list, burnin.length = BURNIN.LEN)
mcmc.out.list.thin <- postTHINN(mcmc.out.list = finalresults$mcmc.out.list, thinningsteps = THINNING)
mcmc.out.list.burn.thin <- postTHINN(mcmc.out.list = mcmc.out.list.burn, thinningsteps = THINNING)
str(mcmc.out.list.burn[1])
str(mcmc.out.list.thin[1])
str(mcmc.out.list.burn.thin[1])
```

### Reformat

```{r}
# thinned only
mc.out.thin.1 <- mcmc.out.list.thin[[1]]
mc.out.thin.2 <- mcmc.out.list.thin[[2]]
mc.out.thin.3 <- mcmc.out.list.thin[[3]]
mc.out.thin.4 <- mcmc.out.list.thin[[4]]

mc.out.thin.score.1 <- mcmc(mc.out.thin.1$scores)
mc.out.thin.score.2 <- mcmc(mc.out.thin.2$scores)
mc.out.thin.score.3 <- mcmc(mc.out.thin.3$scores)
mc.out.thin.score.4 <- mcmc(mc.out.thin.4$scores)

list.mc.out.thin.score <- mcmc.list(mc.out.thin.score.1, mc.out.thin.score.2, mc.out.thin.score.3, mc.out.thin.score.4)

# burned and thinned
mc.out.burn.thin.1 <- mcmc.out.list.burn.thin[[1]]
mc.out.burn.thin.2 <- mcmc.out.list.burn.thin[[2]]
mc.out.burn.thin.3 <- mcmc.out.list.burn.thin[[3]]
mc.out.burn.thin.4 <- mcmc.out.list.burn.thin[[4]]

mc.out.burn.thin.score.1 <- mcmc(mc.out.burn.thin.1$scores)
mc.out.burn.thin.score.2 <- mcmc(mc.out.burn.thin.2$scores)
mc.out.burn.thin.score.3 <- mcmc(mc.out.burn.thin.3$scores)
mc.out.burn.thin.score.4 <- mcmc(mc.out.burn.thin.4$scores)

# list.mc <- mcmc.list(mc.score.1, mc.score.2, mc.score.3, mc.score.4)
list.mc.out.burn.thin.score <- mcmc.list(mc.out.burn.thin.score.1, mc.out.burn.thin.score.2, mc.out.burn.thin.score.3, mc.out.burn.thin.score.4)

mc.out.burn.thin.dag.1 <- mc.out.burn.thin.1$dags
mc.out.burn.thin.dag.2 <- mc.out.burn.thin.2$dags
mc.out.burn.thin.dag.3 <- mc.out.burn.thin.3$dags
mc.out.burn.thin.dag.4 <- mc.out.burn.thin.4$dags

list.mc.out.burn.thin.dag <- abind::abind(mc.out.burn.thin.dag.1, mc.out.burn.thin.dag.2, mc.out.burn.thin.dag.3, mc.out.burn.thin.dag.4)
```

## Best fitting DAG

number of max parents per node.

```{r}
finalresults$max.par
```

total arcs.

```{r}
sum(finalresults$dag.maxpar$dag)
summary(finalresults$fabn.maxpar)
```

## MCMC Quality check

### Gelman
```{r}
gelman.diag(x = list.mc.out.thin.score,autoburnin = F) # if higher than 1.1 or 1.2, run chain longer to improve convergence
gelman.plot(list.mc.out.thin.score, autoburnin = F)

if (SAVEPLOTS){
  PLOTNAME <- paste0("_gelmanplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  }
  
} else {
  gelman.plot(list.mc.out.thin.score, autoburnin = T)
}
```

### Raftery

calculate no. of iterations and no. of burn-ins to satisfy specified conditions.

```{r}
raftery.diag(unlist(list.mc.out.thin.score))
```

### Heidelberg and Welch Diagnostics

test H0: The Markov Chain is from a stationary distribution. If not passed, chain must run longer.

```{r}
for (chain in 1:length(list.mc.out.thin.score)){
  print("------------------------")
  print(paste("Chain no: ", chain))
  print(heidel.diag(list.mc.out.thin.score[[chain]]))
}

```

### Trace Plot

```{r}
mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
# SAVEPLOTS <- T
if (SAVEPLOTS){
  PLOTNAME <- paste0("_traceplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } 
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
  }
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_maxscore"
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
}
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_classic"
  plot(list.mc.out.burn.thin.score)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  plot(list.mc.out.burn.thin.score)
}
```

```{r do we need this?}
# ## traceplot
# fabn <-fitAbn(dag = dag.maxpar$dag,
#               data.df = abndata,
#               data.dists = dist, 
#               method = METHOD) 
# 
# max.score <- -fabn$bic
# 
# dta <- data.frame(mc.out.thin.1[2:4],
#                   mc.out.thin.2[2:4],
#                   mc.out.thin.3[2:4],
#                   mc.out.thin.4[2:4]) # Thinned but not burned
# 
# dta <- dta[,c(1,4,7,10)]
# # dta <- dta[thin, ]
# names(dta) <- c("Run1","Run2","Run3","Run4")
# dta$X <- (1:length(dta$Run1))
# dta <- reshape2::melt(dta, "X", value.name = "scores")
# 
# dta$cummax[1] <- dta$scores[1]
# for (i in 2:length(dta$scores)) {
#   if (dta$scores[i] > dta$cummax[i - 1]) {
#     dta$cummax[i] <- dta$scores[i]
#     } else {
#       dta$cummax[i] <- dta$cummax[i - 1]
#     }
# }
# 
# # Create a text
# 
# original_plot <- ggplot(data = dta, aes_string(x = "X", y="scores", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1) +
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score,alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # print(original_plot)
# 
# # Plot
# y_density <- cowplot::axis_canvas(original_plot, axis = "y", coord_flip = TRUE) +
#   geom_density(data = dta, aes_string(x = "scores",fill = "factor(variable)"), alpha = 0.5) +
#   coord_flip()
# 
# cummax_plt <- ggplot(data = dta, aes_string(x = "X", y="cummax", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1, inherit.aes = T) +
#   geom_point(aes_string(color = "variable"), inherit.aes = T)+
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score, alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # cummax_plt
# 
# # create the combined plot
# combined_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right"))
# combined_cummax_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = cummax_plt, position = "right"))
# # ggsave(paste0(FILENAMEbase, FILENAME, "traceplot_combined.png"),
# #        plot = cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right")),
# #        width = 9,height = 7)
# # dev.off()
# # print(combined_plot)
# 
# if (SAVEPLOTS){
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_combined")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_cummax")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
#   } else {
#   original_plot
#   combined_plot 
#   cummax_plt
# }
```

## Consensus DAG

best dag trimmed for controlling overfitting

```{r}
# Best DAG not trimmed 
dag.mcmc.boot <- apply(list.mc.out.burn.thin.dag, 1:2, mean)
colnames(dag.mcmc.boot) <- rownames(dag.mcmc.boot) <- names(finalresults$dist)

# Best DAG Trimmed on THRESHOLD
dag.mcmc.boot.th <- dag.mcmc.boot
dag.mcmc.boot.th[dag.mcmc.boot.th>THRESHOLD]<-1
dag.mcmc.boot.th[dag.mcmc.boot.th<=THRESHOLD]<-0

# Plot Best DAG trimmed
cons.dag.plt <- plotAbn(dag = dag.mcmc.boot.th,data.dists = finalresults$dist, 
                        node.shape = c("box", "box", "box", "box"),
                        plot = F)


if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag"
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
  abn::toGraphviz(dag.mcmc.boot.th,
                  data.dists = finalresults$dist,
                  data.df = finalresults$df,
                  outfile = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".dot"),
                  directed=TRUE)
  saveRDS(dag.mcmc.boot.th, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".rds"))

  } else {
  cons.dag.plt
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  }
```


## Arc strength significance threshold

```{r}
dag.mcmc.boot.stren <- as.vector(round(dag.mcmc.boot, 3))
arc.stren.sign.threshold <-arc.stren.threshold(dag.mcmc.boot.stren)


# relative arc strength
plot(ecdf(dag.mcmc.boot.stren))
abline(v = arc.stren.sign.threshold, lty=2)
abline(v=0.5)

# # absolute arc strength
# plot(ecdf(apply(list.mc.out.burn.thin.dag, 1:2, sum)))

if (SAVEPLOTS){
  PLOTNAME <- "_cdf_arcstrength"
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
}
```

Difference in DAG between two arc strength thresholds:
```{r}
# relative frequency of an arc appearing in the MCMC sample
x <- dag.mcmc.boot

x[which(x<THRESHOLD & x>arc.stren.sign.threshold)]
x[which(x<THRESHOLD & x>arc.stren.sign.threshold-0.01)] <- 100 # Assign impossible value to highlight arc
x
```


```{r}
# Fit best DAG trimmed 
fabn.boot.th.mle <-fitAbn(dag = dag.mcmc.boot.th,
              data.df = finalresults$df,
              data.dists = finalresults$dist, 
              method = METHOD,
              compute.fixed = T,
              create.graph = T)

fabn.boot.th.mle$bic
infoDag(dag.mcmc.boot.th)

# plot with arc strength
plotdag <- dag.mcmc.boot
plotdag[plotdag>THRESHOLD]<-1
plotdag[plotdag<=THRESHOLD]<-0

fitvals <- fabn.boot.th.mle$coef

for (i in 1:length(fitvals)){
  names(fitvals[[i]]) <- colnames(fitvals[[i]])
}

edgestren <- round(dag.mcmc.boot, 2)
edgestren[edgestren<=THRESHOLD]<-0

cons.dag.plt.edgestrength <- plotAbn(dag = plotdag,
        data.dists = dist,
        # fitted.values = fitvals,
        digits = 2,
        # edge.strength = edgestren,
        # edge.arrowsize = "undirected",
        node.shape = c("box", "box", "box", "box"),
        plot = F)

attrs <- list(node=list(shape="rectangle", fixedsize=FALSE))
if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag_edgestrength"
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
}
```

TODO: fix edge direction. They're all in the wrong direction...

# Exp. 4.3: maBN for each study_source individually


```{r load data}
THRESHOLD <- 0.5
METHOD <- "mle"

filenamesuffix <- "4.3"
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_intermediate.RData"))
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_final.RData"))
str(finalresults, max.level = 1)
```


List of all mcmcabn outputs. 
```{r}
length(finalresults$mcmc.out.list)
```

Show first mcmcabn output.
```{r}
str(finalresults$mcmc.out.list[1])
```

DAG from first mcmcabn output. [rows, columns, dags]. dags = number of returned DAGS specified in mcmcscheme.

```{r}
str(finalresults$mcmc.out.list[[1]]$dags)
```


## Max. parents plot

```{r}
maxparentsplot(net.scores, SAVEPLOTS, filenamesuffix, plotwidth = PLOTWIDTH, plotheight = PLOTHEIGHT, filetype = PLOTFORMAT)
```


### Plot DAGs with different max parents

```{r}
dagswithdiffparentsplt(net.scores.dags, df, SAVEPLOTS, filenamesuffix)
```

## Preprocess
### Thin and Burn-in

thinning: mcmc.scheme = c(number of returned DAGS, thinned steps, length of burn-in phase)

```{r}
# THINNING <- 2 # keep every second draw
# BURNIN.LEN <- 2500 # remove the first n draws
THINNING <- 7
BURNIN.LEN <- 25000 # remove the first n draws

mcmc.out.list.burn <- postBURNin(mcmc.out.list = finalresults$mcmc.out.list, burnin.length = BURNIN.LEN)
mcmc.out.list.thin <- postTHINN(mcmc.out.list = finalresults$mcmc.out.list, thinningsteps = THINNING)
mcmc.out.list.burn.thin <- postTHINN(mcmc.out.list = mcmc.out.list.burn, thinningsteps = THINNING)
str(mcmc.out.list.burn[1])
str(mcmc.out.list.thin[1])
str(mcmc.out.list.burn.thin[1])
```

### Reformat

```{r}
# thinned only
mc.out.thin.1 <- mcmc.out.list.thin[[1]]
mc.out.thin.2 <- mcmc.out.list.thin[[2]]
mc.out.thin.3 <- mcmc.out.list.thin[[3]]
mc.out.thin.4 <- mcmc.out.list.thin[[4]]

mc.out.thin.score.1 <- mcmc(mc.out.thin.1$scores)
mc.out.thin.score.2 <- mcmc(mc.out.thin.2$scores)
mc.out.thin.score.3 <- mcmc(mc.out.thin.3$scores)
mc.out.thin.score.4 <- mcmc(mc.out.thin.4$scores)

list.mc.out.thin.score <- mcmc.list(mc.out.thin.score.1, mc.out.thin.score.2, mc.out.thin.score.3, mc.out.thin.score.4)

# burned and thinned
mc.out.burn.thin.1 <- mcmc.out.list.burn.thin[[1]]
mc.out.burn.thin.2 <- mcmc.out.list.burn.thin[[2]]
mc.out.burn.thin.3 <- mcmc.out.list.burn.thin[[3]]
mc.out.burn.thin.4 <- mcmc.out.list.burn.thin[[4]]

mc.out.burn.thin.score.1 <- mcmc(mc.out.burn.thin.1$scores)
mc.out.burn.thin.score.2 <- mcmc(mc.out.burn.thin.2$scores)
mc.out.burn.thin.score.3 <- mcmc(mc.out.burn.thin.3$scores)
mc.out.burn.thin.score.4 <- mcmc(mc.out.burn.thin.4$scores)

# list.mc <- mcmc.list(mc.score.1, mc.score.2, mc.score.3, mc.score.4)
list.mc.out.burn.thin.score <- mcmc.list(mc.out.burn.thin.score.1, mc.out.burn.thin.score.2, mc.out.burn.thin.score.3, mc.out.burn.thin.score.4)

mc.out.burn.thin.dag.1 <- mc.out.burn.thin.1$dags
mc.out.burn.thin.dag.2 <- mc.out.burn.thin.2$dags
mc.out.burn.thin.dag.3 <- mc.out.burn.thin.3$dags
mc.out.burn.thin.dag.4 <- mc.out.burn.thin.4$dags

list.mc.out.burn.thin.dag <- abind::abind(mc.out.burn.thin.dag.1, mc.out.burn.thin.dag.2, mc.out.burn.thin.dag.3, mc.out.burn.thin.dag.4)
```

## Best fitting DAG

number of max parents per node.

```{r}
finalresults$max.par
```

total arcs.

```{r}
sum(finalresults$dag.maxpar$dag)
summary(finalresults$fabn.maxpar)
```

## MCMC Quality check

### Gelman
```{r}
gelman.diag(x = list.mc.out.thin.score,autoburnin = F) # if higher than 1.1 or 1.2, run chain longer to improve convergence
gelman.plot(list.mc.out.thin.score, autoburnin = F)

if (SAVEPLOTS){
  PLOTNAME <- paste0("_gelmanplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  }
  
} else {
  gelman.plot(list.mc.out.thin.score, autoburnin = T)
}
```

### Raftery

calculate no. of iterations and no. of burn-ins to satisfy specified conditions.

```{r}
raftery.diag(unlist(list.mc.out.thin.score))
```

### Heidelberg and Welch Diagnostics

test H0: The Markov Chain is from a stationary distribution. If not passed, chain must run longer.

```{r}
for (chain in 1:length(list.mc.out.thin.score)){
  print("------------------------")
  print(paste("Chain no: ", chain))
  print(heidel.diag(list.mc.out.thin.score[[chain]]))
}

```

### Trace Plot

```{r}
mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
# SAVEPLOTS <- T
if (SAVEPLOTS){
  PLOTNAME <- paste0("_traceplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } 
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
  }
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_maxscore"
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
}
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_classic"
  plot(list.mc.out.burn.thin.score)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  plot(list.mc.out.burn.thin.score)
}
```

```{r do we need this?}
# ## traceplot
# fabn <-fitAbn(dag = dag.maxpar$dag,
#               data.df = abndata,
#               data.dists = dist, 
#               method = METHOD) 
# 
# max.score <- -fabn$bic
# 
# dta <- data.frame(mc.out.thin.1[2:4],
#                   mc.out.thin.2[2:4],
#                   mc.out.thin.3[2:4],
#                   mc.out.thin.4[2:4]) # Thinned but not burned
# 
# dta <- dta[,c(1,4,7,10)]
# # dta <- dta[thin, ]
# names(dta) <- c("Run1","Run2","Run3","Run4")
# dta$X <- (1:length(dta$Run1))
# dta <- reshape2::melt(dta, "X", value.name = "scores")
# 
# dta$cummax[1] <- dta$scores[1]
# for (i in 2:length(dta$scores)) {
#   if (dta$scores[i] > dta$cummax[i - 1]) {
#     dta$cummax[i] <- dta$scores[i]
#     } else {
#       dta$cummax[i] <- dta$cummax[i - 1]
#     }
# }
# 
# # Create a text
# 
# original_plot <- ggplot(data = dta, aes_string(x = "X", y="scores", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1) +
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score,alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # print(original_plot)
# 
# # Plot
# y_density <- cowplot::axis_canvas(original_plot, axis = "y", coord_flip = TRUE) +
#   geom_density(data = dta, aes_string(x = "scores",fill = "factor(variable)"), alpha = 0.5) +
#   coord_flip()
# 
# cummax_plt <- ggplot(data = dta, aes_string(x = "X", y="cummax", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1, inherit.aes = T) +
#   geom_point(aes_string(color = "variable"), inherit.aes = T)+
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score, alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # cummax_plt
# 
# # create the combined plot
# combined_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right"))
# combined_cummax_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = cummax_plt, position = "right"))
# # ggsave(paste0(FILENAMEbase, FILENAME, "traceplot_combined.png"),
# #        plot = cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right")),
# #        width = 9,height = 7)
# # dev.off()
# # print(combined_plot)
# 
# if (SAVEPLOTS){
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_combined")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_cummax")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
#   } else {
#   original_plot
#   combined_plot 
#   cummax_plt
# }
```

## Consensus DAG

best dag trimmed for controlling overfitting

```{r}
# Best DAG not trimmed 
dag.mcmc.boot <- apply(list.mc.out.burn.thin.dag, 1:2, mean)
colnames(dag.mcmc.boot) <- rownames(dag.mcmc.boot) <- names(finalresults$dist)

# Best DAG Trimmed on THRESHOLD
dag.mcmc.boot.th <- dag.mcmc.boot
dag.mcmc.boot.th[dag.mcmc.boot.th>THRESHOLD]<-1
dag.mcmc.boot.th[dag.mcmc.boot.th<=THRESHOLD]<-0

# Plot Best DAG trimmed
cons.dag.plt <- plotAbn(dag = dag.mcmc.boot.th,data.dists = finalresults$dist, 
                        node.shape = c("box", "box", "box", "box"),
                        plot = F)


if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag"
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
  abn::toGraphviz(dag.mcmc.boot.th,
                  data.dists = finalresults$dist,
                  data.df = finalresults$df,
                  outfile = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".dot"),
                  directed=TRUE)
  saveRDS(dag.mcmc.boot.th, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".rds"))

  } else {
  cons.dag.plt
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  }
```


## Arc strength significance threshold

```{r}
dag.mcmc.boot.stren <- as.vector(round(dag.mcmc.boot, 3))
arc.stren.sign.threshold <-arc.stren.threshold(dag.mcmc.boot.stren)


# relative arc strength
plot(ecdf(dag.mcmc.boot.stren))
abline(v = arc.stren.sign.threshold, lty=2)
abline(v=0.5)

# # absolute arc strength
# plot(ecdf(apply(list.mc.out.burn.thin.dag, 1:2, sum)))

if (SAVEPLOTS){
  PLOTNAME <- "_cdf_arcstrength"
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
}
```

Difference in DAG between two arc strength thresholds:
```{r}
# relative frequency of an arc appearing in the MCMC sample
x <- dag.mcmc.boot

x[which(x<THRESHOLD & x>arc.stren.sign.threshold)]
x[which(x<THRESHOLD & x>arc.stren.sign.threshold-0.01)] <- 100 # Assign impossible value to highlight arc
x
```


```{r}
# Fit best DAG trimmed 
fabn.boot.th.mle <-fitAbn(dag = dag.mcmc.boot.th,
              data.df = finalresults$df,
              data.dists = finalresults$dist, 
              method = METHOD,
              compute.fixed = T,
              create.graph = T)

fabn.boot.th.mle$bic
infoDag(dag.mcmc.boot.th)

# plot with arc strength
plotdag <- dag.mcmc.boot
plotdag[plotdag>THRESHOLD]<-1
plotdag[plotdag<=THRESHOLD]<-0

fitvals <- fabn.boot.th.mle$coef

for (i in 1:length(fitvals)){
  names(fitvals[[i]]) <- colnames(fitvals[[i]])
}

edgestren <- round(dag.mcmc.boot, 2)
edgestren[edgestren<=THRESHOLD]<-0

cons.dag.plt.edgestrength <- plotAbn(dag = plotdag,
        data.dists = dist,
        # fitted.values = fitvals,
        digits = 2,
        # edge.strength = edgestren,
        # edge.arrowsize = "undirected",
        node.shape = c("box", "box", "box", "box"),
        plot = F)

attrs <- list(node=list(shape="rectangle", fixedsize=FALSE))
if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag_edgestrength"
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
}
```

# Exp. 4.4: maBN with study_source as parent of everything


```{r load data}
THRESHOLD <- 0.5
METHOD <- "mle"

filenamesuffix <- "4.4"
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_intermediate.RData"))
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_final.RData"))
str(finalresults, max.level = 1)
```


List of all mcmcabn outputs. 
```{r}
length(finalresults$mcmc.out.list)
```

Show first mcmcabn output.
```{r}
str(finalresults$mcmc.out.list[1])
```

DAG from first mcmcabn output. [rows, columns, dags]. dags = number of returned DAGS specified in mcmcscheme.

```{r}
str(finalresults$mcmc.out.list[[1]]$dags)
```


## Max. parents plot

```{r}
maxparentsplot(net.scores, SAVEPLOTS, filenamesuffix, plotwidth = PLOTWIDTH, plotheight = PLOTHEIGHT, filetype = PLOTFORMAT)
```


### Plot DAGs with different max parents

```{r}
dagswithdiffparentsplt(net.scores.dags, df, SAVEPLOTS, filenamesuffix)
```

## Preprocess
### Thin and Burn-in

thinning: mcmc.scheme = c(number of returned DAGS, thinned steps, length of burn-in phase)

```{r}
# THINNING <- 2 # keep every second draw
# BURNIN.LEN <- 2500 # remove the first n draws
THINNING <- 7
BURNIN.LEN <- 25000 # remove the first n draws

mcmc.out.list.burn <- postBURNin(mcmc.out.list = finalresults$mcmc.out.list, burnin.length = BURNIN.LEN)
mcmc.out.list.thin <- postTHINN(mcmc.out.list = finalresults$mcmc.out.list, thinningsteps = THINNING)
mcmc.out.list.burn.thin <- postTHINN(mcmc.out.list = mcmc.out.list.burn, thinningsteps = THINNING)
str(mcmc.out.list.burn[1])
str(mcmc.out.list.thin[1])
str(mcmc.out.list.burn.thin[1])
```

### Reformat

```{r}
# thinned only
mc.out.thin.1 <- mcmc.out.list.thin[[1]]
mc.out.thin.2 <- mcmc.out.list.thin[[2]]
mc.out.thin.3 <- mcmc.out.list.thin[[3]]
mc.out.thin.4 <- mcmc.out.list.thin[[4]]

mc.out.thin.score.1 <- mcmc(mc.out.thin.1$scores)
mc.out.thin.score.2 <- mcmc(mc.out.thin.2$scores)
mc.out.thin.score.3 <- mcmc(mc.out.thin.3$scores)
mc.out.thin.score.4 <- mcmc(mc.out.thin.4$scores)

list.mc.out.thin.score <- mcmc.list(mc.out.thin.score.1, mc.out.thin.score.2, mc.out.thin.score.3, mc.out.thin.score.4)

# burned and thinned
mc.out.burn.thin.1 <- mcmc.out.list.burn.thin[[1]]
mc.out.burn.thin.2 <- mcmc.out.list.burn.thin[[2]]
mc.out.burn.thin.3 <- mcmc.out.list.burn.thin[[3]]
mc.out.burn.thin.4 <- mcmc.out.list.burn.thin[[4]]

mc.out.burn.thin.score.1 <- mcmc(mc.out.burn.thin.1$scores)
mc.out.burn.thin.score.2 <- mcmc(mc.out.burn.thin.2$scores)
mc.out.burn.thin.score.3 <- mcmc(mc.out.burn.thin.3$scores)
mc.out.burn.thin.score.4 <- mcmc(mc.out.burn.thin.4$scores)

# list.mc <- mcmc.list(mc.score.1, mc.score.2, mc.score.3, mc.score.4)
list.mc.out.burn.thin.score <- mcmc.list(mc.out.burn.thin.score.1, mc.out.burn.thin.score.2, mc.out.burn.thin.score.3, mc.out.burn.thin.score.4)

mc.out.burn.thin.dag.1 <- mc.out.burn.thin.1$dags
mc.out.burn.thin.dag.2 <- mc.out.burn.thin.2$dags
mc.out.burn.thin.dag.3 <- mc.out.burn.thin.3$dags
mc.out.burn.thin.dag.4 <- mc.out.burn.thin.4$dags

list.mc.out.burn.thin.dag <- abind::abind(mc.out.burn.thin.dag.1, mc.out.burn.thin.dag.2, mc.out.burn.thin.dag.3, mc.out.burn.thin.dag.4)
```

## Best fitting DAG

number of max parents per node.

```{r}
finalresults$max.par
```

total arcs.

```{r}
sum(finalresults$dag.maxpar$dag)
summary(finalresults$fabn.maxpar)
```

## MCMC Quality check

### Gelman
```{r}
gelman.diag(x = list.mc.out.thin.score,autoburnin = F) # if higher than 1.1 or 1.2, run chain longer to improve convergence
gelman.plot(list.mc.out.thin.score, autoburnin = F)

if (SAVEPLOTS){
  PLOTNAME <- paste0("_gelmanplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  }
  
} else {
  gelman.plot(list.mc.out.thin.score, autoburnin = T)
}
```

### Raftery

calculate no. of iterations and no. of burn-ins to satisfy specified conditions.

```{r}
raftery.diag(unlist(list.mc.out.thin.score))
```

### Heidelberg and Welch Diagnostics

test H0: The Markov Chain is from a stationary distribution. If not passed, chain must run longer.

```{r}
for (chain in 1:length(list.mc.out.thin.score)){
  print("------------------------")
  print(paste("Chain no: ", chain))
  print(heidel.diag(list.mc.out.thin.score[[chain]]))
}

```

### Trace Plot

```{r}
mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
# SAVEPLOTS <- T
if (SAVEPLOTS){
  PLOTNAME <- paste0("_traceplot")
  if(PLOTFORMAT == "svg"){
  dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } else if(PLOTFORMAT == "pdf"){
  dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
  dev.off()
  } 
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]])
  }
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_maxscore"
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  mcmcabn::plot.mcmcabn(mcmc.out.list.burn.thin[[1]], max.score = TRUE)
}
```


```{r}
if (SAVEPLOTS){
  PLOTNAME <- "_traceplot_classic"
  plot(list.mc.out.burn.thin.score)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  plot(list.mc.out.burn.thin.score)
}
```

```{r do we need this?}
# ## traceplot
# fabn <-fitAbn(dag = dag.maxpar$dag,
#               data.df = abndata,
#               data.dists = dist, 
#               method = METHOD) 
# 
# max.score <- -fabn$bic
# 
# dta <- data.frame(mc.out.thin.1[2:4],
#                   mc.out.thin.2[2:4],
#                   mc.out.thin.3[2:4],
#                   mc.out.thin.4[2:4]) # Thinned but not burned
# 
# dta <- dta[,c(1,4,7,10)]
# # dta <- dta[thin, ]
# names(dta) <- c("Run1","Run2","Run3","Run4")
# dta$X <- (1:length(dta$Run1))
# dta <- reshape2::melt(dta, "X", value.name = "scores")
# 
# dta$cummax[1] <- dta$scores[1]
# for (i in 2:length(dta$scores)) {
#   if (dta$scores[i] > dta$cummax[i - 1]) {
#     dta$cummax[i] <- dta$scores[i]
#     } else {
#       dta$cummax[i] <- dta$cummax[i - 1]
#     }
# }
# 
# # Create a text
# 
# original_plot <- ggplot(data = dta, aes_string(x = "X", y="scores", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1) +
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score,alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # print(original_plot)
# 
# # Plot
# y_density <- cowplot::axis_canvas(original_plot, axis = "y", coord_flip = TRUE) +
#   geom_density(data = dta, aes_string(x = "scores",fill = "factor(variable)"), alpha = 0.5) +
#   coord_flip()
# 
# cummax_plt <- ggplot(data = dta, aes_string(x = "X", y="cummax", color = "variable")) +
#   geom_line(alpha = 0.8,lwd=1.1, inherit.aes = T) +
#   geom_point(aes_string(color = "variable"), inherit.aes = T)+
#   geom_hline(yintercept = max.score,linetype = "dashed", color = "red", alpha = 1) +
#   geom_text(aes(25, max.score, label = round(max.score,digits = 2), vjust = -0.5), color = "red", check_overlap = TRUE) +
#   labs(x = "DAG index", y = "DAG scores", colour = "MCMC:") +
#   ggpubr::theme_pubr()+
#   ylim(min(dta$scores),max(dta$scores)) 
#   # annotate("rect", xmin=0, xmax=BURNIN.LEN, ymin=min(dta$scores), ymax=max.score, alpha = .3) +
#   # geom_text(aes(BURNIN.LEN/THINNING*0.5, min(dta$scores), label = "Burn-in phase", vjust = -0.5, hjust=0), color = "black", check_overlap = TRUE)
# # cummax_plt
# 
# # create the combined plot
# combined_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right"))
# combined_cummax_plot <- cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = cummax_plt, position = "right"))
# # ggsave(paste0(FILENAMEbase, FILENAME, "traceplot_combined.png"),
# #        plot = cowplot::ggdraw(cowplot::insert_yaxis_grob(plot = original_plot, grob = y_density, position = "right")),
# #        width = 9,height = 7)
# # dev.off()
# # print(combined_plot)
# 
# if (SAVEPLOTS){
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_combined")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
# 
#   PLOTNAME <- paste0(getwd(), "/results/", FILENAME,"traceplot_allruns_cummax")
#   ggsave(paste0(PLOTNAME, ".svg"),
#          width = PLOTWIDTH, height = PLOTHEIGHT)  
#   } else {
#   original_plot
#   combined_plot 
#   cummax_plt
# }
```

## Consensus DAG

best dag trimmed for controlling overfitting

```{r}
# Best DAG not trimmed 
dag.mcmc.boot <- apply(list.mc.out.burn.thin.dag, 1:2, mean)
colnames(dag.mcmc.boot) <- rownames(dag.mcmc.boot) <- names(finalresults$dist)

# Best DAG Trimmed on THRESHOLD
dag.mcmc.boot.th <- dag.mcmc.boot
dag.mcmc.boot.th[dag.mcmc.boot.th>THRESHOLD]<-1
dag.mcmc.boot.th[dag.mcmc.boot.th<=THRESHOLD]<-0

# Plot Best DAG trimmed
cons.dag.plt <- plotAbn(dag = dag.mcmc.boot.th,data.dists = finalresults$dist, 
                        node.shape = c("box", "box", "box", "box"),
                        plot = F)


if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag"
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
  abn::toGraphviz(dag.mcmc.boot.th,
                  data.dists = finalresults$dist,
                  data.df = finalresults$df,
                  outfile = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".dot"),
                  directed=TRUE)
  saveRDS(dag.mcmc.boot.th, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".rds"))

  } else {
  cons.dag.plt
  dag = bnlearn::empty.graph(names(finalresults$df))
  bnlearn::amat(dag) = t(dag.mcmc.boot.th)
  bnlearn::graphviz.plot(dag,
                         shape = "rectangle",
                         main = paste("MCMC ABN DAG", filenamesuffix))
  }
```


## Arc strength significance threshold

```{r}
dag.mcmc.boot.stren <- as.vector(round(dag.mcmc.boot, 3))
arc.stren.sign.threshold <-arc.stren.threshold(dag.mcmc.boot.stren)


# relative arc strength
plot(ecdf(dag.mcmc.boot.stren))
abline(v = arc.stren.sign.threshold, lty=2)
abline(v=0.5)

# # absolute arc strength
# plot(ecdf(apply(list.mc.out.burn.thin.dag, 1:2, sum)))

if (SAVEPLOTS){
  PLOTNAME <- "_cdf_arcstrength"
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
}
```

Difference in DAG between two arc strength thresholds:
```{r}
# relative frequency of an arc appearing in the MCMC sample
x <- dag.mcmc.boot

x[which(x<THRESHOLD & x>arc.stren.sign.threshold)]
x[which(x<THRESHOLD & x>arc.stren.sign.threshold-0.01)] <- 100 # Assign impossible value to highlight arc
x
```


```{r}
# Fit best DAG trimmed 
fabn.boot.th.mle <-fitAbn(dag = dag.mcmc.boot.th,
              data.df = finalresults$df,
              data.dists = finalresults$dist, 
              method = METHOD,
              compute.fixed = T,
              create.graph = T)

fabn.boot.th.mle$bic
infoDag(dag.mcmc.boot.th)

# plot with arc strength
plotdag <- dag.mcmc.boot
plotdag[plotdag>THRESHOLD]<-1
plotdag[plotdag<=THRESHOLD]<-0

fitvals <- fabn.boot.th.mle$coef

for (i in 1:length(fitvals)){
  names(fitvals[[i]]) <- colnames(fitvals[[i]])
}

edgestren <- round(dag.mcmc.boot, 2)
edgestren[edgestren<=THRESHOLD]<-0

cons.dag.plt.edgestrength <- plotAbn(dag = plotdag,
        data.dists = dist,
        # fitted.values = fitvals,
        digits = 2,
        # edge.strength = edgestren,
        # edge.arrowsize = "undirected",
        node.shape = c("box", "box", "box", "box"),
        plot = F)

attrs <- list(node=list(shape="rectangle", fixedsize=FALSE))
if (SAVEPLOTS){
  PLOTNAME <- "_consensus_dag_edgestrength"
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
  if(PLOTFORMAT == "svg"){
    dev.print(svg, filename = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  } else if(PLOTFORMAT == "pdf"){
    dev.print(pdf, file = paste0(FILENAMEbase, FILENAME, filenamesuffix, PLOTNAME, ".", PLOTFORMAT), width = PLOTWIDTH, height = PLOTHEIGHT)
    dev.off()
  }
} else {
  Rgraphviz::plot(cons.dag.plt.edgestrength, attrs=attrs)
}
```

# Exp. 4.5: maBN mixed-effect with study_source as random-effect


## load data
```{r message=FALSE, warning=FALSE}
filenamesuffix <- "TEST4.5"
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_intermediate.RData"))
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_final.RData"))
load(paste0(FILENAMEbase, FILENAME, filenamesuffix, "_paramBootAbnConsDAG.RData"))
```
## Max. parents plot 

```{r}
maxparentsplot(net.scores, SAVEPLOTS, filenamesuffix, plotwidth = PLOTWIDTH, plotheight = PLOTHEIGHT, filetype = PLOTFORMAT)
```


## Consensus DAG

```{r}
plot(consfit)
print(consfit)
```

## Arc strength significance threshold

TODO

## Cross-validation for rupture prediction under a mixed-effects model

Study source as mixed-effect (discrete-mixed effect BN)

```{r}
cv_ROCAUC(data = data, node = "IAruptured", parents = c("A", "B")) # TODO: parents
```

